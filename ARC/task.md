## Выполните задание:

### Описать несколько структур

#### Структуры
- любой легковой автомобиль 
- любой грузовик. 

Структуры должны содержать марку авто, год выпуска, объем багажника/кузова, запущен ли двигатель, открыты ли окна, заполненный объем багажника

#### Описать перечисление с возможными действиями с автомобилем:
-  запустить/заглушить двигатель
-  открыть/закрыть окна 
- погрузить/выгрузить из кузова/багажника груз определенного объема

Добавить в структуры метод с одним аргументом типа перечисления, который будет менять свойства структуры в зависимости от действия

Инициализировать несколько экземпляров структур. Применить к ним различные действия. 
Положить объекты структур в словарь как ключи, а их названия как строки например var dict = [structCar: 'structCar']

> Решение задания описано в файле car.swift

### Capture List

Почитать о Capture List (см ссылку ниже) - и описать своими словами и сделать скрин своего примера и объяснения Capture

>Capture List в Swift используется для захвата значений извне замыкания, чтобы избежать циклических ссылок (retain cycles) при работы с захваченными объектами. Это важно при использовании замыканий внутри захватывающих объектов, например, внутри классов.
>
>Capture List позволяет явно указать, какие переменные или константы должны быть захвачены и как они должны быть захвачены внутри замыкания. Это делается с помощью квадратных скобок [] после указания параметров ввода замыкания.
>
>Вот простой пример использования Capture List (из файла person.swift):

    class Person {
        let name: String
        lazy var greeting: () -> String = { [weak self] in
            guard let self = self else { return "Ссылка на self потеряна" }
            return "Привет, меня зовут \(self.name)!"
        }
        
        init(name: String) {
            self.name = name
        }
        
        deinit {
            print("\(name) удален из памяти")
        }
    }

    var person: Person? = Person(name: "Игорь")
    print(person?.greeting() ?? "Что-то пошло не так")
    person = nil

> В этом примере был создан класс Person с переменной name и замыканием greeting, которое содержит Capture List [weak self], чтобы избежать утечек памяти. Затем мы создаем объект Person и вызываем greeting. Когда объект Person устанавливается в nil, мы видим, как сообщение об освобождении памяти выводится на консоль.


#### Первый скриншот 

Набрать код который на скриншоте понять в чем там проблема и решить эту проблему

> Исправленный код в файле error1.swift

>Проблема на скриншоте заключается в том, что объекты **car** и **man** держат ссылки друг на друга, создавая **циклическую зависимость**. При car?.driver = man, объект car захватывает ссылку на man, а при man?.myCar = car, объект man захватывает ссылку на car. В результате, при car = nil и man = nil, **объекты не освобождаются из памяти из-за циклической зависимости.**
>
>Для решения этой проблемы можно использовать **Capture List** в замыканиях, чтобы избежать утечки памяти. Нобходимо захватить объекты car и man как слабые (weak) или безопасные в опциональных значениях (unowned) в замыканиях, которые могут вызываться при уничтожении объектов. 

Код, представленный на скриншоте:

    class Car {
        var driver: Man?

        deinit {
            print("Машина удалена из памяти")
        }
    }

    class Man {
        var myCar: Car?

        deinit {
            print("Мужчина удален из памяти")
        }
    }

    var car: Car? = Car()
    var man: Man? = Man()

    car?.driver = man
    man?.myCar = car

    car = nil
    man = nil

> Чтобы исправить проблему с циклической зависимостью, нужно сделать свойства driver и myCar слабыми (weak) или безопасными в опциональных значениях (unowned). Например, можно изменить объявление свойства driver в классе Car следующим образом: 

Исправленный код:

    class Car {
        weak var driver: Man?

        deinit {
            print("Машина удалена из памяти")
        }
    }

> Таким образом, после исправления утечки памяти объекты будут освобождены корректно.

#### Второй скриншот

У нас есть класс мужчины и его паспорта. Мужчина может родиться и не иметь паспорта, но паспорт выдается конкретному мужчине и не может выдаваться без указания владельца. Чтобы разрешить эту проблему, ссылку на паспорт у мужчины сделаем опциональной, а ссылку на владельца у паспорта – константой. Также добавим паспорту конструктор, чтобы сразу определить его владельца. Таким образом, человек сможет существовать без паспорта, сможет его поменять или выкинуть, но паспорт может быть создан только с конкретным владельцем и никогда не может его сменить. Повторить все что на черном скрине и решить проблему соблюдая все правила!

> Исправленный код в файле error2.swift

> Проблема на скриншоте заключается в том, что мужчина и паспорт замыкаются друг на друга, из-за чего происходит утечка памяти - ссылки высвобождаются, а объекты не уничтожаются. Сперва была идея сделать ссылку на мужчину unowned, однако при этом мы получили бы краш проекта, если бы удалили мужчину и попытались бы обратиться к нему из объекта паспорта. Поэтому, было принято решение сделать опциональный захват паспорта.

    class Man {
        var pasport: (() -> Passport?)? // По заданию weak или unowned запрещено ставить
        
        deinit {
            // выведем в консоль сообщение о том, что объект удален
            print("мужчина удален из памяти")
        }
    }